//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.7.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export interface IClient {
  getName(): Promise<void>;

  getDocs(): Promise<void>;

  getUsersId(): Promise<void>;

  deleteCat(): Promise<void>;

  postCat(): Promise<void>;

  /**
   * @return The record has been successfully created.
   */
  getEnvCat(): Promise<void>;

  create(body: CreateCatDto): Promise<void>;

  findAll(): Promise<void>;

  findOne(id: string): Promise<void>;

  update(id: number, body: CreateCatDto): Promise<void>;

  remove(id: string): Promise<void>;

  findAllCat(): Promise<void>;

  createCat(body: CreateCatDto): Promise<void>;

  create2(body: HumanDto): Promise<void>;

  findAll2(): Promise<void>;

  testQueue(): Promise<void>;

  /**
   * @return The record has been successfully created.
   */
  updateAccount(accountId: number, body: UpdateAccountDto): Promise<Account>;

  /**
   * @return The record has been successfully created.
   */
  findAccountId(accountId: number): Promise<Account>;

  deleteOne(accountId: number): Promise<void>;

  /**
   * @return The record has been successfully created.
   */
  getAllAccount(): Promise<Account>;

  uploadFile(): Promise<void>;

  uploadFileAndPassValidation(): Promise<void>;

  uploadFiles(): Promise<void>;

  handleGetFile(filename: string): Promise<void>;

  signIn(): Promise<void>;

  createAccount(body: CreateAccountDto): Promise<void>;

  getCurrentAccount(): Promise<void>;

  signOut(): Promise<void>;
}

export class Client implements IClient {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> },
  ) {
    this.http = http || (window as any);
    this.baseUrl = baseUrl ?? '';
  }

  getName(): Promise<void> {
    let url_ = this.baseUrl + '/hello';
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {},
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetName(_response);
    });
  }

  protected processGetName(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  getDocs(): Promise<void> {
    let url_ = this.baseUrl + '/test/docs';
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {},
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetDocs(_response);
    });
  }

  protected processGetDocs(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  getUsersId(): Promise<void> {
    let url_ = this.baseUrl + '/test/{userId}';
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {},
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetUsersId(_response);
    });
  }

  protected processGetUsersId(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  deleteCat(): Promise<void> {
    let url_ = this.baseUrl + '/test/delete';
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'DELETE',
      headers: {},
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processDeleteCat(_response);
    });
  }

  protected processDeleteCat(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  postCat(): Promise<void> {
    let url_ = this.baseUrl + '/test/post';
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'POST',
      headers: {},
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processPostCat(_response);
    });
  }

  protected processPostCat(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 300) {
      return response.text().then((_responseText) => {
        return throwException(
          'A server side error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @return The record has been successfully created.
   */
  getEnvCat(): Promise<void> {
    let url_ = this.baseUrl + '/api/v1/cats/test-env';
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {},
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetEnvCat(_response);
    });
  }

  protected processGetEnvCat(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 201) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  create(body: CreateCatDto): Promise<void> {
    let url_ = this.baseUrl + '/api/v1/cats/test-dto';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processCreate(_response);
    });
  }

  protected processCreate(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 201) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  findAll(): Promise<void> {
    let url_ = this.baseUrl + '/api/v1/cats/test-query';
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {},
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processFindAll(_response);
    });
  }

  protected processFindAll(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  findOne(id: string): Promise<void> {
    let url_ = this.baseUrl + '/api/v1/cats/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {},
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processFindOne(_response);
    });
  }

  protected processFindOne(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  update(id: number, body: CreateCatDto): Promise<void> {
    let url_ = this.baseUrl + '/api/v1/cats/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUpdate(_response);
    });
  }

  protected processUpdate(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  remove(id: string): Promise<void> {
    let url_ = this.baseUrl + '/api/v1/cats/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'DELETE',
      headers: {},
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processRemove(_response);
    });
  }

  protected processRemove(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  findAllCat(): Promise<void> {
    let url_ = this.baseUrl + '/api/v1/cats/get-all-cats';
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {},
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processFindAllCat(_response);
    });
  }

  protected processFindAllCat(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  createCat(body: CreateCatDto): Promise<void> {
    let url_ = this.baseUrl + '/api/v1/cats/create-cat';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processCreateCat(_response);
    });
  }

  protected processCreateCat(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 201) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  create2(body: HumanDto): Promise<void> {
    let url_ = this.baseUrl + '/humans';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processCreate2(_response);
    });
  }

  protected processCreate2(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 201) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  findAll2(): Promise<void> {
    let url_ = this.baseUrl + '/humans/get-all';
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {},
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processFindAll2(_response);
    });
  }

  protected processFindAll2(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  testQueue(): Promise<void> {
    let url_ = this.baseUrl + '/api/v1/accounts/queue';
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {},
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processTestQueue(_response);
    });
  }

  protected processTestQueue(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @return The record has been successfully created.
   */
  updateAccount(accountId: number, body: UpdateAccountDto): Promise<Account> {
    let url_ = this.baseUrl + '/api/v1/accounts/{accountId}';
    if (accountId === undefined || accountId === null)
      throw new Error("The parameter 'accountId' must be defined.");
    url_ = url_.replace('{accountId}', encodeURIComponent('' + accountId));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUpdateAccount(_response);
    });
  }

  protected processUpdateAccount(response: Response): Promise<Account> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 201) {
      return response.text().then((_responseText) => {
        let result201: any = null;
        let resultData201 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result201 = Account.fromJS(resultData201);
        return result201;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<Account>(null as any);
  }

  /**
   * @return The record has been successfully created.
   */
  findAccountId(accountId: number): Promise<Account> {
    let url_ = this.baseUrl + '/api/v1/accounts/{accountId}';
    if (accountId === undefined || accountId === null)
      throw new Error("The parameter 'accountId' must be defined.");
    url_ = url_.replace('{accountId}', encodeURIComponent('' + accountId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processFindAccountId(_response);
    });
  }

  protected processFindAccountId(response: Response): Promise<Account> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 201) {
      return response.text().then((_responseText) => {
        let result201: any = null;
        let resultData201 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result201 = Account.fromJS(resultData201);
        return result201;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<Account>(null as any);
  }

  deleteOne(accountId: number): Promise<void> {
    let url_ = this.baseUrl + '/api/v1/accounts/{accountId}';
    if (accountId === undefined || accountId === null)
      throw new Error("The parameter 'accountId' must be defined.");
    url_ = url_.replace('{accountId}', encodeURIComponent('' + accountId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'DELETE',
      headers: {},
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processDeleteOne(_response);
    });
  }

  protected processDeleteOne(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @return The record has been successfully created.
   */
  getAllAccount(): Promise<Account> {
    let url_ = this.baseUrl + '/api/v1/accounts';
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetAllAccount(_response);
    });
  }

  protected processGetAllAccount(response: Response): Promise<Account> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 201) {
      return response.text().then((_responseText) => {
        let result201: any = null;
        let resultData201 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result201 = Account.fromJS(resultData201);
        return result201;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<Account>(null as any);
  }

  uploadFile(): Promise<void> {
    let url_ = this.baseUrl + '/api/v1/files/upload';
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'POST',
      headers: {},
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUploadFile(_response);
    });
  }

  protected processUploadFile(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 201) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  uploadFileAndPassValidation(): Promise<void> {
    let url_ = this.baseUrl + '/api/v1/files/file-validate';
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'POST',
      headers: {},
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUploadFileAndPassValidation(_response);
    });
  }

  protected processUploadFileAndPassValidation(
    response: Response,
  ): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 201) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  uploadFiles(): Promise<void> {
    let url_ = this.baseUrl + '/api/v1/files/files-validate';
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'POST',
      headers: {},
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUploadFiles(_response);
    });
  }

  protected processUploadFiles(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 201) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  handleGetFile(filename: string): Promise<void> {
    let url_ = this.baseUrl + '/api/v1/files/get-file/{filename}';
    if (filename === undefined || filename === null)
      throw new Error("The parameter 'filename' must be defined.");
    url_ = url_.replace('{filename}', encodeURIComponent('' + filename));
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {},
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processHandleGetFile(_response);
    });
  }

  protected processHandleGetFile(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  signIn(): Promise<void> {
    let url_ = this.baseUrl + '/api/v1/auth/sign-in';
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'POST',
      headers: {},
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processSignIn(_response);
    });
  }

  protected processSignIn(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  createAccount(body: CreateAccountDto): Promise<void> {
    let url_ = this.baseUrl + '/api/v1/auth/sign-up';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processCreateAccount(_response);
    });
  }

  protected processCreateAccount(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 201) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  getCurrentAccount(): Promise<void> {
    let url_ = this.baseUrl + '/api/v1/auth/current-account';
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {},
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetCurrentAccount(_response);
    });
  }

  protected processGetCurrentAccount(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  signOut(): Promise<void> {
    let url_ = this.baseUrl + '/api/v1/auth/sign-out';
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'POST',
      headers: {},
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processSignOut(_response);
    });
  }

  protected processSignOut(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 201) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }
}

export class CreateCatDto implements ICreateCatDto {
  [key: string]: any;

  constructor(data?: ICreateCatDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) this[property] = _data[property];
      }
    }
  }

  static fromJS(data: any): CreateCatDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateCatDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    for (var property in this) {
      if (this.hasOwnProperty(property)) data[property] = this[property];
    }
    return data;
  }
}

export interface ICreateCatDto {
  [key: string]: any;
}

export class HumanDto implements IHumanDto {
  /** The name of human */
  name!: string;
  /** The age */
  age!: number;
  gender!: boolean;
  address!: string;

  [key: string]: any;

  constructor(data?: IHumanDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.name = 'John';
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) this[property] = _data[property];
      }
      this.name = _data['name'] !== undefined ? _data['name'] : 'John';
      this.age = _data['age'];
      this.gender = _data['gender'];
      this.address = _data['address'];
    }
  }

  static fromJS(data: any): HumanDto {
    data = typeof data === 'object' ? data : {};
    let result = new HumanDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    for (var property in this) {
      if (this.hasOwnProperty(property)) data[property] = this[property];
    }
    data['name'] = this.name;
    data['age'] = this.age;
    data['gender'] = this.gender;
    data['address'] = this.address;
    return data;
  }
}

export interface IHumanDto {
  /** The name of human */
  name: string;
  /** The age */
  age: number;
  gender: boolean;
  address: string;

  [key: string]: any;
}

export class UpdateAccountDto implements IUpdateAccountDto {
  /** Email of account */
  email?: string;
  password?: string;
  role?: UpdateAccountDtoRole;

  [key: string]: any;

  constructor(data?: IUpdateAccountDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.email = '1';
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) this[property] = _data[property];
      }
      this.email = _data['email'] !== undefined ? _data['email'] : '1';
      this.password = _data['password'];
      this.role = _data['role'];
    }
  }

  static fromJS(data: any): UpdateAccountDto {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateAccountDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    for (var property in this) {
      if (this.hasOwnProperty(property)) data[property] = this[property];
    }
    data['email'] = this.email;
    data['password'] = this.password;
    data['role'] = this.role;
    return data;
  }
}

export interface IUpdateAccountDto {
  /** Email of account */
  email?: string;
  password?: string;
  role?: UpdateAccountDtoRole;

  [key: string]: any;
}

export class Account implements IAccount {
  id!: number;
  email!: string;
  username!: string;
  password!: string;
  role!: string;

  [key: string]: any;

  constructor(data?: IAccount) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) this[property] = _data[property];
      }
      this.id = _data['id'];
      this.email = _data['email'];
      this.username = _data['username'];
      this.password = _data['password'];
      this.role = _data['role'];
    }
  }

  static fromJS(data: any): Account {
    data = typeof data === 'object' ? data : {};
    let result = new Account();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    for (var property in this) {
      if (this.hasOwnProperty(property)) data[property] = this[property];
    }
    data['id'] = this.id;
    data['email'] = this.email;
    data['username'] = this.username;
    data['password'] = this.password;
    data['role'] = this.role;
    return data;
  }
}

export interface IAccount {
  id: number;
  email: string;
  username: string;
  password: string;
  role: string;

  [key: string]: any;
}

export class CreateAccountDto implements ICreateAccountDto {
  /** Email of account */
  email!: string;
  password!: string;
  role!: CreateAccountDtoRole;

  [key: string]: any;

  constructor(data?: ICreateAccountDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.email = '1';
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) this[property] = _data[property];
      }
      this.email = _data['email'] !== undefined ? _data['email'] : '1';
      this.password = _data['password'];
      this.role = _data['role'];
    }
  }

  static fromJS(data: any): CreateAccountDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateAccountDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    for (var property in this) {
      if (this.hasOwnProperty(property)) data[property] = this[property];
    }
    data['email'] = this.email;
    data['password'] = this.password;
    data['role'] = this.role;
    return data;
  }
}

export interface ICreateAccountDto {
  /** Email of account */
  email: string;
  password: string;
  role: CreateAccountDtoRole;

  [key: string]: any;
}

export enum UpdateAccountDtoRole {
  User = 'user',
  Admin = 'admin',
}

export enum CreateAccountDtoRole {
  User = 'user',
  Admin = 'admin',
}

export class ApiException extends Error {
  override message: string;
  status: number;
  response: string;
  headers: { [key: string]: any };
  result: any;

  constructor(
    message: string,
    status: number,
    response: string,
    headers: { [key: string]: any },
    result: any,
  ) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  protected isApiException = true;

  static isApiException(obj: any): obj is ApiException {
    return obj.isApiException === true;
  }
}

function throwException(
  message: string,
  status: number,
  response: string,
  headers: { [key: string]: any },
  result?: any,
): any {
  if (result !== null && result !== undefined) throw result;
  else throw new ApiException(message, status, response, headers, null);
}
